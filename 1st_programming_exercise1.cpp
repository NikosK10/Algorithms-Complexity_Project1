/*  Αρχικά ταξινομούμε τα διαστήματα [si,fi] με βάση την αρχή τους si.
    Έπειτα, θα περιγράψουμε την δυαδική αναζήτηση για τη επίλυση του προβλήματος.
    Θελουμε τη μεγιστοποίηση της ελάχιστης απόστασης μεταξύ των καταστημάτων. (Δηλαδή θέλουμε τα καταστήματα να έχουν την μέγιστη δυνατή απόσταση).
    Η μέγιστη ελάχιστη απόσταση (dmin) γενικά είναι μεταξύ low=1 και high=max(fi)-min(si).
    Θέτουμε dmin=mid=(low+high)/2 και ελέγχουμε εάν τα Ν καταστήματα χωράνε στα M διαστήματα μας έχοντας αυτή την απόσταση ΤΟΥΛΑΧΙΣΤΟΝ.
    Συγκεκριμένα, τοποθετώ το 1ο στην 1η διαθεσιμη θέση και το δεύετερο dmin θέσεις μετά εκτός εάν δε γίνεται άρα μπαίνει στην πρώτη διαθέσιμη θέση>dmin.
    EAN: τα διαστήματα τελειώσουν πριν τοποθετήσω και τα N καταστήματα τότε απόσταση όχι εφικτή και θέτουμε high=mid-1 και επανελαβε.
    EAN: χωρέσουν τα Ν καταστήματα ελέγχω μήπως μπορώ και πιο μεγάλο dmin άρα low=mid+1 και επανελαβε.
    ΤΕΡΜΑΤΙΣΜΟΣ: όταν low>high

*/


#include <iostream>
#include <algorithm>
using namespace std;


// Συνάρτηση για να ελέγξουμε αν μπορούμε να τοποθετήσουμε τα καταστήματα με δεδομένη απόσταση
bool canPlaceStores(int N, int M, pair<int, int> spaces[], int dmin) {
    int placed_stores = 1;  // Αρχίζουμε από το 1 γιατί το πρώτο κατάστημα έχει ήδη τοποθετηθεί στην πρωτη διαθεσιμη θεση
    int last_position = spaces[0].first;  // Τοποθετούμε το πρώτο κατάστημα στην αρχή του πρώτου διαστήματος

    for (int i = 0; i < M; ++i) {
        int start = spaces[i].first;
        int end = spaces[i].second;
        // Ξεκινάμε να τοποθετούμε το κατάστημα από την πρώτη θέση που είναι τουλάχιστον d_min μακριά από το προηγούμενο
        int position =  max(start, last_position + dmin);

        // Τοποθετούμε τα καταστήματα σε αυτήν την περιοχή
        while (position <= end) {
            placed_stores++;
            last_position = position;
            if (placed_stores == N) {
                return true;  // Έχουν τοποθετηθεί όλα τα καταστήματα
            }
            position += dmin;  // Προχωράμε στην επόμενη θέση με απόσταση τουλάχιστον d_min
        }
    }

    return false;  // Δεν καταφέραμε να τοποθετήσουμε όλα τα καταστήματα
}


int main() {
    int N, M;
    scanf("%d %d", &N, &M);

    pair<int, int> spaces[M];  // Πίνακας διαστημάτων τύπου pair<int, int>

    // Διαβάζουμε τα διαστήματα
    for (int i = 0; i < M; ++i) {
        scanf("%d %d",&spaces[i].first, &spaces[i].second);
    }

    // Ταξινομούμε τα διαστήματα κατά αύξουσα σειρά με βάση την αρχή τους (si)
    sort(spaces, spaces + M);

    // Αρχικοποίηση για δυαδική αναζήτηση
    int low = 1, high = spaces[M - 1].second - spaces[0].first;
    int dmin = 0;

    // Δυαδική αναζήτηση
    while (low <= high) {
        int mid = (low + high) / 2;
        if (canPlaceStores(N, M, spaces, mid)) {
            dmin = mid; // Μπορούμε να τοποθετήσουμε τα καταστήματα με αυτή την απόσταση dmin
            low = mid + 1;  // Δοκιμάζουμε μεγαλύτερη απόσταση
        } else {
            high = mid - 1;  // Δεν μπορούμε να τοποθετήσουμε τα καταστήματα με αυτή την απόσταση dmin και δοκιμάζουμε μικρότερη απόσταση
        }
    }

    // Εκτύπωση της μέγιστης δυνατής ελάχιστης απόστασης
    printf("%d\n",dmin);

    return 0;
}